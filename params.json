{"name":"Rawr","tagline":"A word that means \"I Love You\" in dinosaur.","body":"## Welcome to Rawr\r\n\r\n### What is Rawr?\r\n\r\nRawr is a word that means \"I love you\" in dinosaur, but it also is this small library build to implement a lot of features to the PHP language.\r\nRawr is an open-source project meant to make the PHP language a few better, as much as it has a lot of little failures that sometimes let me angry. The project started after a big criticism to PHP and its inconsistence with function names and the design of the language. To solve a big part of these problems, we got Rawr. It implements and simulates static-typing (via contracts by wrappers), functional programming (piping, method-chaining, monads, typeclasses, algebraic-data-types, pattern-matching), a more pure object-orientation (with the concept of Self and Smalltalk OO, where everything is an object that can receive and pass messages) and the concept of modules, in a way similar as Python or Haskell do, aiming a more pure way to program and taking into account that so many developers do several mistakes and workarouns with PHP. Rawr is build to be type-safe and for applications that require to not crash.\r\n\r\n### Static typing\r\n\r\nDifferent from Java, where primitives aren't objects, here each type is literally a class and each value of a rawr-defined variable is a pure object. As much as Alan Kays definition of object-orientation, the objects have behaviors and Rawr also allows method-chaining in order to make the things and calls easier. You can also restrict function parameters to specified types or derived types to assert type-safety:\r\n\r\n```php\r\n$age = Int (18);\r\n$ableToDrive = Lambda (\r\n  /** :: Int -> Bool */\r\n  function (Int $age) {\r\n    return $age -> greaterOrEq (18);\r\n  }\r\n);\r\n\r\n$ableToDrive($age) -> inspect (); // Object (bool);\r\n```\r\n\r\nSome types are derived, this is, as example, `Int` and `Float` are derived from `Num` type, therefore we can make a function that accepts any of them as a parameter:\r\n\r\n```php\r\n$sqrtOf = Lambda (\r\n  /** :: Num -> Float */\r\n  function (Num $n) { return $n -> sqrt (); }\r\n);\r\n```\r\n\r\nRawr uses a Haskell-like type-system, you can use almost of Haskell type definitions here, with PHP.\r\n\r\n### Functional programming\r\n\r\nRawr implements several functional concepts, such as function-composition, pattern-matching, monads or algebraic-data-types.\r\n\r\n```php\r\n$multiplyTwo = Lambda (\r\n  /** :: Int -> Int */\r\n  function (Int $n) {\r\n    return $n -> times (2);\r\n});\r\n\r\n$multiplyThree = Lambda (\r\n  /** :: Int -> Int */\r\n  function (Int $n) {\r\n    return $n -> times (3);\r\n});\r\n\r\n$multiplySix = $multiplyTwo -> o ($multiplyThree);\r\n$multiplySix(Int (7)) -> toString () -> putStrLn (); // => 42\r\n```\r\n\r\nYou can easily handle lists by chaining methods:\r\n\r\n```php\r\n$myList = ยง (1, '...', 10) -> of (\"Data.Num.Int\")\r\n-> map (Lambda (function (Int $n) { return $n -> times (Int (2)); }))\r\n-> filter (Lambda (function (Int $n) { return $n -> isEven (); })\r\n-> reduce (\"+\");\r\n```\r\n\r\n### Smalltalk-based object orientation\r\n\r\nIn Rawr, almost everything is an object. The behaviors of these objects are determined according to their types, e.g.: objects of `Str` class can have a side-effect behavior called `putStrLn` that outputs its content to screen, as much as objects of bool atoms, `true` and `false` can have behaviors like `ifTrue` and `ifFalse`. You don't use conditionals, loops or other imperative structures. You enjoy the pureness of well-designed languages to work with your computations:\r\n\r\n```php\r\n$oddNumTil100 = (new Collection (1, 3 '...', 100)) -> of (\"Data.Num.Int\")\r\n-> filter (Lambda (function (Int $n) { return $n -> greaterOrEq (50); }))\r\n-> each   (Lambda (function (Int $n) { Show ($n) -> putStrLn (); }));\r\n\r\n$magicHappens = $oddNumTil100 -> contains (Int (7))\r\n-> ifTrue (Lambda (function () { Str (\"Yes, it containts 7.\") -> putStrLn (); }))\r\n-> ifFalse (Lambda (function () { Str (\"No, there is no 7.\") -> putStrLn (); }));\r\n```\r\n\r\n### Monads for work with computations that may fail\r\n\r\nRawr implements also most of Haskell built-in monads, such as `Maybe` and `Either`. You can chain operations and work with computations that may fail, you can also apply pattern-matching to check for your results. In Rawr, you use no exceptions, there is no errors. You can have a data-type for errors in `Data.Error` that is returned when something goes wrong. You can match its pattern.\r\n\r\n```php\r\n$numberOne  = Int (1);\r\n$numberZero = Int (0);\r\n# Here operation can be Just _ or Nothing.\r\n$operation  = Maybe ($numberOne -> div ($numberZero));\r\n\r\n# Applying identity and chaining computations as much as \"programmable semicolons\".\r\n$operation -> bind (function (Int $res) { return $res });\r\n\r\n# enum Maybe<T> { Just<T>, Nothing }\r\nMatch ($operation) -> withConstr ([\r\n  \"Data.Maybe.Just x\"  => function ($x) { Str (\"We got a result: \\(0).\") -> format ($res -> fromJust ()) -> putStrLn (); }\r\n, \"Data.Maybe.Nothing\" => function () { Str (\"Operation failure.\") -> putStrLn (); }\r\n]);\r\n\r\n$eitherOperation = Either ($numberOne -> div ($numberZero));\r\n$eitherOperation -> either (\r\n  function ($_) { Str (\"Error. Division by 0.\"); }\r\n, function (Int $x) { Str (\"Value: \\(0)\") -> format ($x) -> putStrLn (); }\r\n);\r\n\r\n# enum Either<T> { Left<T>, Right<T> }\r\nMatch ($eitherOperation) -> withConstr ([\r\n  \"Data.Either.Right x\" => function ($x) { Str (\"Value: \\(0)\") -> format ($x -> val ()) -> putStrLn (); }\r\n, otherwise             => function () { Str (\"Error. Division by 0.\"); }\r\n]);\r\n\r\n```\r\n\r\n### Prototype-based-programming\r\n\r\nRawr also supports a Self/Javascript based prototype programming, in a much more expressive way than class-based-programming does, and also provides first class data-types for better data-abstraction:\r\n\r\n```php\r\nType (\"Employee\") -> where (function ($type) {\r\n  $type -> derives (String);\r\n  $type -> with    ([\"Programmer\"\r\n                   , \"Boss\"\r\n                   , \"DBA\"        => \"Database administrator\"]);\r\n});\r\n\r\n# Type Dollars that derives Maybe and Float and is Nothing() by default\r\nType (\"Dollars\") -> derives ([Maybe, Float]) -> def (Nothing ());\r\n\r\n$worker = Object ([\r\n  $name => String\r\n, $age  => Int\r\n, $salary => Dollars\r\n, $position => Employee\r\n]);\r\n\r\n$worker -> prototype -> greet = Lambda (\r\n  function ($self) {\r\n    Str (\"Hello, I'm \\(name) and I'm \\(age) years old!\")\r\n    -> format ([\"name\" => $self -> name\r\n              , \"age\"  => $self -> age])\r\n    -> putStrLn ();\r\n  }\r\n);\r\n\r\n$worker -> prototype -> sayPosition = Lambda (\r\n  function ($self) {\r\n    Str (\"I'm a \\(0) here.\") -> format ($self -> position)\r\n    -> putStrLn ();\r\n  }\r\n);\r\n\r\n$sophia = $worker -> instance ();\r\n# or:\r\n# $sophia = clone $worker;\r\n\r\n$sophia -> with ([\r\n  \"name\"     => \"Sophia J.\"\r\n, \"age\"      => 19\r\n, \"salary\"   => Just (3500)\r\n, \"position\" => Type (Employee) -> Programmer;\r\n]);\r\n\r\n$sophia -> greet ();\r\n$sophia -> sayPosition ();\r\n```","google":"UA-59956631-1","note":"Don't delete this file! It's used internally to help with page regeneration."}